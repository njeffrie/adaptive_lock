{
  "name": "Adaptive Lock",
  "tagline": "Usage sensitive locking for critical sections facing changing workloads",
  "body": "### Authors and Contributors\r\nNat Jeffries (@njeffrie)\r\nMadhav Ieyngar (@miyengar)\r\n\r\n### Summary\r\nWe are implementing a locking library which adapts the type of lock used internally as well as takes advantage of the transaction instructions available on Intel processors.\r\n\r\n### Background \r\nLocks perform better on some workloads than on others, and it's often difficult to figure out which type of lock should be used when the workload is not well defined.  It becomes even more difficult when new locking constructs are available, such as Intel's new transaction instructions.  There is lots of research on locking and which locks perform best on which workloads, and we are planning to build on that information to implement a workload-sensitive lock which dynamically changes the type of lock used internally to protect each critical section in a piece of code. \r\n\r\n### The Challenge\r\nThis is a challenging project for several reasons.  First, we will need to implement several existing locks and benchmark them with a variety of workloads.  We will then need to figure out exactly how to transition between types of locks without breaking any of the critical section invariants guaranteed to the programmer.  We also will be playing around with atomic transactions available on newer intel processors, and deal with the possibilities of transitioning between atomic transactions to protect our critical sections, and traditional locking. \r\n\r\n### Resources\r\nWe will be doing most of our testing on the Xeon Phi multiprocessor machines available in the latedays cluster.  If time permits we may experiment with additional machines or architectures.\r\n\r\n### Deliverables\r\n-Accurate benchmarks for simple spinlocks, sleeping mutexes, MCS Spinlocks, Readers-Writers locks, and optimistic atomic transactions.\r\n-Expose a simple locking API which encapsulates several locking mechanisms, and chooses between them based on the workload encountered.\r\n-Demonstrate measurable speedup over traditional locking when faced by a changing workload\r\n\r\n### Goals\r\n-Intelligently choose which locks to use based on system architecture\r\n-Demonstrate comparable performance when compared to well-chosen locking on a static workload\r\n-Implement traditional benchmark algorithms with our locks and show performance relative to traditional locks\r\n\r\n### Expectations\r\n-Present graphs of speedup over traditional locks\r\n-Present at least one example workload program, and how to replace traditional locks with our library\r\n\r\n### Platform Choice\r\nWe plan on developing for linux, specifically the Xeon Phi hardware platform available on latedays. We hope to extend our implementation to other architectures.\r\n\r\n### Schedule\r\nWeek of 4/4 - Begin implementing locks.  Download and begin experimenting with benchmark suites.\r\nWeek of 4/11 -  Finish Implementing and testing versions of spinlocks, mutexes, MCS spinlocks, and readers-writers locks. Demonstrate at least spinlocks, mutexes, and readers-writers locks for midpoint demo, as well as benchmarks gathered.\r\nWeek of 4/18 - Combine locks under single API, develop logic to transition between them.\r\nWeek of 4/25 - Complete implementation, begin tuning when to choose what lock based on benchmarks gathered at the beginning.\r\nWeek of 5/2 - Finalize implementaiton, experiment changing architecture if time allows.  Finalize webpage before 5/7.\r\n5/9- Parallelism Competition\r\n\r\n### Project Checkpoint\r\nWe have completed implementations for all of the locks we intend to use, and have begun analyzing the performance of each lock on the latedays phi machines.  We have already found improvements up to 15% with simple locking tests on workloads which involve high contention across a large number of processors when compared to pthread mutexes.  We have begun exploring the PARASEC benchmarks and plan to begin inserting our locks in the place of mutexes, omp critical sections and other locking.\r\n\r\nMoving forward, we plan to finish thorough testing and evaluation of our reader writer locks under various reader/writer ratios, and begin unifying our implementations under a single locking interface with an underlying state machine to choose which type of locking to use.  We will benchmark each lock type changing reader to writer ratio, contention, and critical section duration.  We plan to evaluate access latencies to make our final decisions for which lock to use under each workload.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}